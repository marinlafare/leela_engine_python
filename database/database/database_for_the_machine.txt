#LEELA MAIN
import os
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket
from contextlib import asynccontextmanager
from constants import CONN_STRING
from database.database.engine import init_db
from database.routers import fen, collect_fens
#from database.operations.collect_fens import collect_fens
# lifespan event handler for new implementation
@asynccontextmanager
async def lifespan(app: FastAPI):
    init_db(CONN_STRING)
    print('...LEELA Server ON...')
    yield
    print('...LEELA Server DOWN YO!...')

app = FastAPI(lifespan=lifespan)

@app.get("/")
def read_root():
    return "LEELA server running."

app.include_router(fen.router)
app.include_router(collect_fens.router)
import os

# CONSTANTS

import os
from dotenv import load_dotenv
load_dotenv('this_is_not_an_env.env')
USER=os.getenv("USER")
PASSWORD=os.getenv("PASSWORD")
HOST=os.getenv('HOST')
PORT=os.getenv("PORT")
DATABASE_NAME = os.getenv("DATABASE_NAME")
CONN_STRING = os.getenv("CONN_STRING").replace('{user}',USER)
CONN_STRING = CONN_STRING.replace('{host}',HOST)
CONN_STRING = CONN_STRING.replace('{password}',PASSWORD)
CONN_STRING = CONN_STRING.replace('{port}',PORT)
CONN_STRING = CONN_STRING.replace('{database_name}',DATABASE_NAME)

# LEELA_ENGINE_CONSTANTS

LC0_PATH = os.getenv("LEELA_EXE")
lc0_directory = os.path.dirname(LC0_PATH)
LC0_WEIGHTS_FILE = os.getenv("WEIGHTS")

#ROUTERS_FEN

import asyncio
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from database.operations.fen import analize_fen 

router = APIRouter()

@router.get("/fen/{fen:path}")
async def api_read_player_fen_analysis(fen: str):
    """
    Analyzes a chess FEN position using the Lc0 (leela) engine.

    Args:
        fen: The FEN string of the chess position.

    Returns:
        JSONResponse: A JSON response containing the analysis results.
    """
    try:
        fen_analysis = await analize_fen(fen) 
        return JSONResponse(content=fen_analysis)
    except Exception as e:
        print(f"Error in API endpoint for FEN {fen}: {e}")
        return JSONResponse(content={"error": f"Failed to analyze FEN: {e}"}, status_code=500)

#ROUTERS_COLLECT_FENS

import asyncio
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from database.operations.collect_fens import collect_fens_operations 

router = APIRouter()

@router.get("/collect_fens/{n_fens}")
async def api_read_player_fen_analysis(n_games: int):
    try:
        fen_analysis = await collect_fens_operations(n_games)
        return JSONResponse(content=fen_analysis)
    except Exception as e:
        print(f"Error in API endpoint for Collecting FENS : {e}")
        return JSONResponse(content={"error": f"Failed to analyze FEN: {e}"}, status_code=500)
# OPERATIONS_FENS
import os
import chess
import chess.engine
import asyncio
from constants import LC0_PATH, lc0_directory, LC0_WEIGHTS_FILE
from database.operations.models import FenCreateData
from database.database.db_interface import DBInterface
from database.database.models import Fen, MainFen
async def initialize_lc0_engine() -> chess.engine.UciProtocol:
    """
    Launches and configures the Leela Chess Zero (Lc0) engine.
    Returns:
        An initialized Lc0 engine instance (chess.engine.UciProtocol).
    Raises:
        Exception: If the engine fails to launch or configure.
    """
    engine_uci = None
    try:
        print("Launching Lc0 engine...")
        transport, engine_uci = await chess.engine.popen_uci(
            LC0_PATH,
            cwd=lc0_directory
        )

        weights = os.path.join(lc0_directory, LC0_WEIGHTS_FILE)
        await engine_uci.configure({
            "WeightsFile": weights,
            "Backend": "cuda-fp16",
            "Threads": 1,
            "MinibatchSize": 1024
        })

        return engine_uci
    except Exception as e:
        print(f"Error initializing Lc0 engine: {e}")
        if engine_uci:
            await engine_uci.quit()
        raise

async def analyze_single_position(engine_uci: chess.engine.UciProtocol,
                                  fen: str, nodes_limit: int = 50000) -> dict:
    """
    Analyzes a fen with Leela.
    
    Args:
        engine_uci: Leela engine instance.
        fen: a self explanatory fen.
        nodes_limit: The maximum number of nodes Lc0 should explore, default:50_000.

    Returns:
        A dictionary containing score in centipawns and principal variation and stuff.
    """
    board = chess.Board(fen)

    # "2 validation errors for FenCreateData\nfen\n  Field required [type=missing, input_value={'depth': 12, 'seldepth':...'d7d5', 'f3e5', 'd5e4']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.10/v/missing\nnode_per_second\n  Field required [type=missing, input_value={'depth': 12, 'seldepth':...'d7d5', 'f3e5', 'd5e4']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.10/v/missing"

    try:
        limit = chess.engine.Limit(nodes=nodes_limit)
        info = await engine_uci.analyse(board, limit=limit)
        score = info["score"].white().score(mate_score=10000) / 100
        pv = [move.uci() for move in info["pv"]]
        info['fen'] = fen
        info['score'] = score
        info['pv'] = ''.join([move+'##' for move in pv])
        print(info)
        fen_interface = DBInterface(Fen)
        fen_data = FenCreateData(**info)
        fen_interface.create(fen_data.model_dump())
        
        return info

    except Exception as e:
        print(f"An error occurred during Lc0 analysis for FEN {fen}: {e}")
        return {"fen": fen, "error": str(e)}


async def analize_fen(fen: str) -> dict:
    """
    Initializes a Leela engine instance.
    Asks the engine for the analysis of the fen.
    
    Args:
        fen: a string in a fen format.
    Returns:
        A dictionary containing the fen as key and the stuff as values.
    """
    engine = None
    try:
        engine = await initialize_lc0_engine() 
        analysis_result = await analyze_single_position(engine, fen, nodes_limit=50000)
        return analysis_result
    except Exception as e:
        print(f"Error in analize_fen for FEN {fen}: {e}")
        return {"fen": fen, "error": f"Analysis failed: {e}"}
    finally:
        if engine:
            print(f"Quitting Lc0 engine for FEN {fen}...")
            await engine.quit()
            print(f"Lc0 engine quit for FEN {fen}.")

#OPERATIONS_COLLECT_FENS
import time
import chess
from collections import defaultdict
from typing import Any, Dict

import asyncio
from itertools import chain
from fastapi import WebSocketDisconnect
from database.operations.connection import Connection
from database.database.ask_db import get_new_games_links, get_fens_from_games, get_new_fens, get_one_game,open_request
from database.operations.models import MainFenCreateData
from database.database.db_interface import DBInterface
from database.database.models import MainFen, Fen


# --- Helper function: Generates FENs for a single game's moves ---
def generate_fens_for_single_game_moves(moves: list[dict]) -> list[str]:
    """
    Generates a sequence of FENs for a single chess game given its moves.

    Args:
        moves (list[dict]): A list of dictionaries, where each dictionary represents
                            a move with keys 'n_move', 'white_move', 'black_move'.
                            Example: [{'n_move': 1, 'white_move': 'e4', 'black_move': 'e5'}]

    Returns:
        list[str]: A list of FEN strings representing the board state after each half-move.
                   Returns a partial list or an empty list if an invalid move is encountered,
                   along with a printed error message.
    """
    board = chess.Board()
    fens_sequence = []
    
    for ind, move in enumerate(moves):
        # Basic assertion to check move order consistency,
        # There are some games that begin in a random move, we don't want those
        if move['n_move'] != ind + 1:
            print(f"Warning: n_move mismatch for move {move['n_move']} at index {ind}. Expected {ind + 1}. "
                  f"Processing might be out of order for this game.")
            return False
            
        n_move = move['n_move']
        white_move_san = move.get('white_move') # Use .get() for safer access
        black_move_san = move.get('black_move') # Use .get() for safer access

        # Apply White's move and get FEN
        if white_move_san: # Only attempt if white_move exists
            try:
                move_obj_white = board.parse_san(white_move_san)
                board.push(move_obj_white)
                fens_sequence.append(board.fen())
            except (ValueError, chess.InvalidMoveError) as e:
                print(f"Error applying White's move '{white_move_san}' at move number {n_move}: {e}")
                # Stop processing this game if an invalid move is found
                return fens_sequence
        
        # Apply Black's move and get FEN (only if black_move exists and white's move was successful)
        if black_move_san: # Only attempt if black_move exists
            try:
                move_obj_black = board.parse_san(black_move_san)
                board.push(move_obj_black)
                fens_sequence.append(board.fen())
            except (ValueError, chess.InvalidMoveError) as e:
                print(f"Error applying Black's move '{black_move_san}' at move number {n_move}: {e}")
                # Stop processing this game if an invalid move is found
                return fens_sequence
                
    return fens_sequence

# --- Optimized Database Fetching Function ---
def get_all_moves_for_links_batch(game_links: list[str]) -> dict[str, list[dict]]:
    """
    Fetches all moves for a given list of game links in a single batched query
    to the database.

    Args:
        game_links (list[str]): A list of game links (URLs or unique identifiers).

    Returns:
        dict[str, list[dict]]: A dictionary where keys are game links and values are lists of
                               move dictionaries, sorted by 'n_move' for each game.
                               Returns an empty dictionary if no links are provided or no
                               moves are found.
    """
    if not game_links:
        return {}

    # SQL query to select moves for all provided links.
    # Using UNNEST for the array parameter is efficient for PostgreSQL.
    # IMPORTANT FIX: Added ::bigint cast to ensure type compatibility with 'link' column.
    sql_query = """
    SELECT link, n_move, white_move, black_move
    FROM moves
    WHERE link IN (SELECT unnest(%s::text[])::bigint)
    ORDER BY link, n_move;
    """
    
    # open_request is assumed to execute the query with parameterized input
    # and return a list of tuples (link, n_move, white_move, black_move).
    result_tuples = open_request(sql_query, params=(game_links,))

    # Group the fetched moves by game link for easier processing
    grouped_moves = defaultdict(list)
    for row in result_tuples:
        link, n_move, white_move, black_move = row
        grouped_moves[link].append({
            'n_move': n_move,
            'white_move': white_move,
            'black_move': black_move
        })
    return grouped_moves

# --- Main FEN Generation Orchestrator (Optimized) ---
def get_fens_from_games_optimized(new_game_links_data: list[tuple]) -> list[str]:
    """
    Retrieves and generates unique FENs for a list of game links.
    This version is optimized to fetch all game moves in a single batched query
    to significantly reduce execution time.

    Args:
        new_game_links_data (list[tuple]): A list of tuples, where each tuple's
                                           first element is a game link.
                                           Typically, this comes from get_new_games_links.

    Returns:
        list[str]: A unique list of FEN strings generated from all processed games.
    """
    all_fens = set()
    game_links_only = [x[0] for x in new_game_links_data]

    start_db_fetch = time.time()
    # Fetch all moves for all games in a single batched query
    all_game_moves_grouped = get_all_moves_for_links_batch(game_links_only)
    db_fetch_time = time.time() - start_db_fetch
    print(f"Time to fetch all game moves from DB (batched): {db_fetch_time:.4f} seconds")

    total_fen_generation_time = 0
    games_processed = 0
    
    for game_link in game_links_only:
        game_moves = all_game_moves_grouped.get(game_link)
        
        if game_moves:
            fen_gen_start = time.time()
            try:
                game_fens = generate_fens_for_single_game_moves(game_moves)
                all_fens.update(game_fens) # Add FENs to the set
                games_processed += 1
            except Exception as e: # Catch any unexpected errors during FEN generation
                print(f"An unexpected error occurred while processing game {game_link}: {e}")
                # Continue to the next game even if one game fails
            total_fen_generation_time += (time.time() - fen_gen_start)
        else:
            print(f"No moves found in the database for game link: {game_link}")

    if games_processed > 0:
        print(f"Mean FEN generation time per game (excluding DB fetch): {total_fen_generation_time / games_processed:.4f} seconds")
    
    return list(all_fens) # Convert the set back to a list for the final output

def get_new_fens(posible_fens: list[str]) -> list[str]:
    """
    Compares a list of possible FENs against known FENs in the 'rawfen' table
    and returns only the FENs that are not already present.

    Args:
        posible_fens (list[str]): A list of FEN strings to check.

    Returns:
        list[str]: A list of FEN strings that are new (not in 'rawfen').
    """
    if not posible_fens:
        return []

    # REVISED SQL QUERY using LEFT JOIN and WHERE IS NULL for better performance
    sql_query = """
    SELECT p_fen.f
    FROM UNNEST(%s::text[]) AS p_fen(f)
    LEFT JOIN main_fen AS rf ON p_fen.f = rf.fen
    WHERE rf.fen IS NULL;
    """
    
    # open_request is assumed to handle the query and return results.
    result_tuples = open_request(sql_query, params=(posible_fens,))
    valid_fens = list(chain.from_iterable(result_tuples))
    return valid_fens

# --- Functions for Inserting Data (Adjusted for your DBInterface) ---
def insert_fens(fens_to_insert: Dict):
    """
    Inserts a list of new FENs into the rawfen table.
    """
    try:
        to_insert_fens = [MainFenCreateData(**fen_data).model_dump() for fen_data in fens_to_insert]
        rawfen_interface = DBInterface(MainFen) 
        rawfen_interface.create_all(to_insert_fens)
        print(f"Successfully inserted {len(fens)} FENs.")
    except Exception as e:
        print(f"Error inserting FENs: {e}")
        # The DBInterface.create_all method should handle internal rollback/commit/close
        # We re-raise if you want the outer script to know about the failure.
        raise

def insert_games(links: list[tuple]):
    """
    Inserts a list of game links into the knownfens table.
    """
    try:
        to_insert_games = [KnownfensCreateData(**{'link':x[0]}).model_dump() for x in links]
        game_interface = DBInterface(Knownfens) # Removed 'session=session'
        game_interface.create_all(to_insert_games)
        print(f"Successfully inserted {len(links)} game links.")
    except Exception as e:
        print(f"Error inserting game links: {e}")
        # The DBInterface.create_all method should handle internal rollback/commit/close
        # We re-raise if you want the outer script to know about the failure.
        raise
async def collect_fens_operations(n_games):
    
    new_game_links = get_new_games_links(n_games) 
    start_total_fen_gen = time.time()
    fen_set_from_games = get_fens_from_games_optimized(new_game_links)
    print(f'{len(fen_set_from_games)} fens from {len(new_game_links)}',time.time()-start_total_fen_gen)
    start_new_fens_check = time.time()
    new_fens = get_new_fens(fen_set_from_games)
    print(f'{len(new_fens)} fens','time elapsed: ',time.time()-start_new_fens_check)
    
    print("\n--- Inserting data into the database ---")
    start_insert_fens = time.time()
    insert_fens(new_fens)
    print('insert_fens time elapsed: ', time.time() - start_insert_fens)
    
    start_insert_games = time.time()
    insert_games(new_game_links)
    print('insert_games time elapsed: ', time.time() - start_insert_games)
    return f"{len(new_fens)} NEW FENS from {len(new_game_links)} NEW GAMES"

def simplify_fen_and_extract_counters_for_insert(full_fen: str) -> tuple[str, str]:
    """
    Takes a full FEN string, extracts the halfmove clock and fullmove number,
    and returns the simplified FEN along with the extracted counters as a string.

    Args:
        full_fen (str): The complete FEN string (e.g., 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1').

    Returns:
        tuple[str, str]: A tuple containing:
            - The simplified FEN string (without halfmove clock and fullmove number).
            - A string containing the halfmove clock and fullmove number, separated by '#'.
              Returns an empty string for counters if the FEN format is unexpected.
    """
    parts = full_fen.split(' ')

    if len(parts) >= 4: # Ensure there are at least 4 parts (piece placement, active color, castling, en passant)
        simplified_fen_parts = parts[0:4]
        simplified_fen = ' '.join(simplified_fen_parts)

        # Extract the last two parts if they exist
        if len(parts) >= 6:
            halfmove_clock = parts[4]
            fullmove_number = parts[5]
            extracted_counters = f"#{halfmove_clock}#{fullmove_number}#_"
        else:
            extracted_counters = "" # Or handle error/log if expecting these parts
            print(f"Warning: FEN '{full_fen}' does not contain expected halfmove or fullmove numbers.")
    else:
        # Handle cases where the FEN is too short or malformed
        simplified_fen = full_fen # Return original FEN if it's too short to parse meaningfully
        extracted_counters = ""
        print(f"Error: Malformed FEN string provided: '{full_fen}'. Expected at least 4 parts.")

    return {"fen":simplified_fen, "n_games": 1, "moves_counter":extracted_counters}
